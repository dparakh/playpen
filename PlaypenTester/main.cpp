#include <Playpen/playpen.h>
#include <Playpen/fgw_text.h>
#include <Playpen/point2dx.h>
#include <Playpen/line_drawing.h>
#include <cmath>
#include <string>
#include <Playpen/shape.h>
#include <Playpen/flood_fill.h>

using namespace fgw;
using namespace std;

void verticals(playpen & pp, int begin_x, int begin_y, int end_y,
               int interval, int count, hue shade){
	for(int line(0); line != count; ++line){
		vertical_line(pp, begin_x + line * interval, begin_y, end_y, shade);
	}
}

void horizontals(playpen & pp, int begin_y, int begin_x, int end_x,
                 int 	interval, int count, hue shade){
	for(int line(0); line != count; ++line){	
		horizontal_line(pp, begin_y + line * interval, 
                        begin_x, end_x, shade);
	}
}

void square_grid(playpen & pp,int begin_x,int begin_y, 
                 int interval, int count, hue shade){
	verticals(pp, begin_x, begin_y,
              begin_y + interval * (count - 1),
              interval, count, shade);
	horizontals(pp, begin_y, begin_x, begin_x + interval * (count - 1),
                interval, count, shade);
	pp.plot(begin_x + interval * (count - 1),
			begin_y + interval * (count - 1), shade);
}

// small wrapper function to produce a full window grid offset from 
// the bottom left it assumes that the playpen is using a scale of 2, if
// that is not true, it will continue to work but less efficiently

void tartan_grid(playpen & pp, int offset, int interval, hue h){
	square_grid(pp, offset-127, offset-127, interval, 2+256/interval, h);
}

int mainold()
{
    playpen paper(green2);

    paper.scale(2);
    paper.plot(0, 0, red4);
    paper.scale(1);
    paper.plot(0, 0, white);
    horizontal_line(paper, 0, -50, 50, blue2);
    vertical_line(paper, 0, -50, 50, blue2);
    drawline(paper, -20, -10, 20, 10, red2);
    drawline(paper, -20, -15, 20, 5, red1);
    drawline(paper, -20, 15, 20, 5, torquoise);
    drawline(paper, -20, 20, 20, 10, torquoise);
    paper.display();
    cout << "press RETURN";
    cin.get();
    return 0;
} 

int main()
{
		playpen paper;
        shape pentagon = make_regular_polygon(100, 4);
        moveshape (pentagon, point2d(0,0));
        drawshape(paper, pentagon, blue4);
        paper.display();
        seed_fill(paper, 0, 0, green2, blue4);
        paper.display();
        cin.get();
        return 0;
}


int maino(){
	try{
		playpen paper;
		paper.scale(2);
		paper.setplotmode(disjoint);
        paper.display();
		srand(read<int>("Enter a whole number."));
		cout << "I need the minimum and maximum mesh for the grid.\n";
		int const minmesh(read<int>("The smallest mesh size is: "));
		int const maxmesh(read<int>("The largest mesh size is:  "));
		int const maxoffset(read<int>
                            ("The variation in the location of the grids is: "));
		int const mesh_range(abs(maxmesh-minmesh)+1);
		for(int i(0); i != 1;){
            int const repetitions(read<int>("How many superimposed grids? "));
            int const hesitate(read<int>("What repetition rate? (0 for fastest. 1000 for one per second): "));
            //	  	  	  string garbage;
            //	  	  	  getline(cin, garbage);  //clear out the last Return key
            // The above two lines have been commented out as the use of read<> makes
            // them unnecessary.
			if(repetitions == 0) i = 1;
			else{ 
				for(int j(0); j != repetitions; ++j){  
					tartan_grid(paper, 
                                rand()%maxoffset, 
                                minmesh + rand()%mesh_range,
                                rand()%256);
					paper.display();
					Wait(hesitate);
				}
			}
		}
		cout << "Press Return to end program";
		cin.get();
	}
	catch(...){
		cout << "Something unexpected happened.\n";
	}
    return 0;
}
